# Курсовая работа по курсу «Вычислительные системы» (первый семестр)

Студент группы: M80-107Б, Павлов Иван Дмитриевич\
Контакты: pavlov.id.2003@mail.ru\
Работа выполнена: 09.12.2021\
Преподаватель: Найденов Иван Евгеньевич\

## 1. Тема

Процедуры и функции в качестве параметров

## 2. Цель работы

Написать программу на языке Си, которая выводит таблицу значений решения трансцендентных алгебраических уравнений тремя способами: Дихотомии (половинного деления), итераций и Ньютона. При этом необходимо пользоваться методом передачи функций в качестве аргументов.

## 3. Задание

| №  | Уравнение | a | b |
| -- | ----------- | - | - |
| 16 | <code>![equation1](/equation1.png)</code>| 2.0 | 3.0 | 
| 17 | <code>![equation2](/equation2.png)</code>| 0.0 | 2.0 |

## 4. Теоретическая часть

#### 1. Метод дихотомии

Так как корень уравнения равен значению х при f(x) = 0, то если взять отрезок с определенным приближением, то значения функции слева от него и справа от него будут иметь разные знаки (f(a) * f(b) < 0). Метод заключается в нахождении середины отрезка и последовательного сужения в зависимости от знака функции:
1. f(a) * f((a+b)/2) > 0:<br>
  a<sub>i</sub> = (a<sub>i - 1</sub> + b<sub>i - 1</sub>) / 2;<br>
  b<sub>i</sub> = b<sub>i - 1</sub> / 2;<br>
2. f(a) * f((a+b)/2) < 0:<br>
  a<sub>i</sub> = a<sub>i - 1</sub> / 2;<br>
  b<sub>i</sub> = (a<sub>i - 1</sub> + b<sub>i - 1</sub>) / 2;<br>
Условие окончания: | b<sub>i - 1</sub> - a<sub>i - 1</sub> | < ε, где ε - приближение.

#### 2. Метод итераций

Идея заключается в замене исходного уравнения f(x) = 0 на уравнение x = f(x). Перед началом итерационного процесса необхоодимо проверить условие сходимости: |f'(x)| < 1, x ∈ [a, b]. Изначально x равен (a + b)/2. Итерационный процесс: x<sub>i + 1</sub> = f(x<subi</sub>).

#### 3. Метод Ньютона

Является частным случаем метода итераций, отличается условие выхода из цикла: |f(x) * f''(x)| < (f'(x))<sup>2</sup> и итерационным процессом: x<sub>i + 1</sub> = x<sub>i</sub> - (f(x<sub>i</sub>)/f'(x<sub>i</sub>)).

## 5. Текст кода

```
#include <stdio.h>
#include <math.h>

double f1(double x) 
{
    return 3.0f * sin(pow(x, 0.5f)) + 0.35f * x - 3.8f;
}

double df1(double x) 
{
    return 3.0f * cos(pow(x, 0.5f)) * 0.5f * pow(x, (-1.0f) * 0.5f) + 0.35f;   
}

double ddf1(double x) 
{
    return (-1.0f) * (3.0f * cos(pow(x, 0.5f)) * 0.25 * pow(x, (-1.0f) * (1.5f)) + 3 * sin(pow(x, 0.5)) * 0.25 * pow(x, (-1.0f)));  
}

double f2(double x) 
{
    return 0.25f * x * x * x + x - 1.2502f;
}

double df2(double x) 
{
    return 0.25f * 3.0f * x * x + 1;
}

double ddf2(double x) 
{
    return 0.25f * 3.0f * 2.0f * x;
}


double dichotomy(double (*f)(double x), double eps, double a, double b) 
{
    while (fabs(a - b) >= eps) {
        if (f(a) * f((a + b) / 2.0f) > 0) {
            a = (a + b) / 2.0f;
        } else {
            b = (a + b) / 2.0f;
        }
    }
    return (a + b) / 2.0f;
}

double iter(double (*f)(double x), double (*df)(double x), double eps, double a, double b) 
{
    int flag = 1;

    for (double x = a; x <= b && flag; x += eps) {
        if (fabs(1 - (df(x) / df((a + b) / 2.0f))) >= 1) {
            flag = 0;
        }
    }

    if (flag) {
        double x0, x1;
        x0 = (a + b) / 2.0f;
        x1 = x0 - (f(x0) / df((a + b) / 2.0f));
        while (fabs(x1 - x0) >= eps) {
            x0 = x1;
            x1 = x0 - (f(x0) / df((a + b) / 2.0f));
        }
        return x1;
    } else {
        return a - 1.0f;
    }

}

double newton(double (*f)(double x), double (*df)(double x), double (*ddf)(double x), double eps, double a, double b) 
{
    int flag = 1;
    for (double x = a; x <= b && flag; x += eps) {
        if (fabs(f(x) * ddf(x)) >= df(x) * df(x)) {
            flag = 0;
        }
    }

    if (flag) {
        double x = b;
        while (fabs(f(x)) >= eps) {
            x = x - f(x) / df(x);
        }
        return x;
    } else {
        return a - 1.0f;
    }
}

int main() {
    double eps, x;
    printf("f1(x) = 3sin(sqrt(x)) + 0.35x - 3.8\nf2(x) = 0.25x^3 + x - 1.2502\n");
    printf("Точность: ");
    scanf("%lf", &eps);
    printf("+-----------------------------+----------+-----------+-----------------------+--------------------------+\n");
	printf("|         Уравнение           | Отрезок  | Метод     | Прибл. значение корня | Прибл. значение функции  |\n");
	printf("+-----------------------------+----------+-----------+-----------------------+--------------------------+\n");
    x = newton(f1, df1, ddf1, eps, 2.0f, 3.0f);
    if (x >= 2.0f) {
		printf("| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Ньютона   | %lf\t             | %lf \t\t|\n", x, f1(x));
	} else {
		printf("| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Ньютона   | Не вычислимо\t     | %lf \t\t|\n", f1(x));
	}
    x = dichotomy(f1, eps, 2.0f, 3.0f);
    if (x >= 2.0f) {
		printf("| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Дихотомии | %lf\t             | %lf \t\t|\n", x, f1(x));
	} else {
		printf("| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Дихотомии | Не вычислимо\t     | %lf \t\t|\n", f1(x));
	}
	x = iter(f1, df1, eps, 2.0f, 3.0f);
	if (x >= 2.0f) {
		printf("| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Итераций  | %lf\t             | %lf \t\t|\n", x, f1(x));
	} else {
		printf("| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Итераций  | Не вычислимо\t     | %lf \t\t|\n", f1(x));
	}
    x = newton(f2, df2, ddf2, eps, 0.0f, 2.0f);
    if (x >= 0.0f) {
		printf("| 0.25x^3 + x - 1.2502        | [0, 2]   | Ньютона   | %lf\t             | %lf \t\t|\n", x, f2(x));
	} else {
		printf("| 0.25x^3 + x - 1.2502        | [0, 2]   | Ньютона   | Не вычислимо\t     | %lf \t\t|\n", f2(x));
	}
    x = dichotomy(f2, eps, 0.0f, 2.0f);
    if (x >= 0.0f) {
		printf("| 0.25x^3 + x - 1.2502        | [0, 2]   | Дихотомии | %lf\t             | %lf \t\t|\n", x, f2(x));
	} else {
		printf("| 0.25x^3 + x - 1.2502        | [0, 2]   | Дихотомии | Не вычислимо\t     | %lf \t\t|\n", f2(x));
	}
    x = iter(f2, df2, eps, 0.0f, 2.0f);a
    if (x >= 0.0f) {
		printf("| 0.25x^3 + x - 1.2502        | [0, 2]   | Итераций  | %lf\t             | %lf \t\t|\n", x, f2(x));
	} else {
		printf("| 0.25x^3 + x - 1.2502        | [0, 2]   | Итераций  | Не вычислимо\t     | %lf \t\t|\n", f2(x));
	}
	printf("+-----------------------------+----------+-----------+-----------------------+--------------------------+\n");
    return 0;
}
```
## 6. Описание кода

1) Напишем функции, соответствующие f1() (функция из варианта 16), f2() (функция из варианта 17), соответственно им df1(), df2(), ddf1(), ddf2() - первые и вторые производные.
2) Напишем функции, соответствующие описанным выше методам дихотомии, итераций, Ньютона. В качестве аргументов этих функций будем принимать помимо переменных типа double, функции, описанные в пункте 1), c помощью указателей (double*) на функцию и аргумента этой функции типа double.
3) В соответствии с условием, выведем результаты подсчета обеих функций и аргументов всеми тремя способами, либо ошибку в случае несоблюдения условия выхода из цикла.

## 7. Запуск кода

### Формат входных данных:

На ввод подаётся одно число - точность вычисления ε.

### Формат результата:

Прежде всего выводятся функции f1 и f2, затем в виде таблицы - результаты, описанные выше.

## 8. Тесты

**Тест 1:**

Ввод: 0,01

Вывод:

```
f1(x) = 3sin(sqrt(x)) + 0.35x - 3.8
f2(x) = 0.25x^3 + x - 1.2502
Точность: 0.1
+-----------------------------+----------+-----------+-----------------------+--------------------------+
|         Уравнение           | Отрезок  | Метод     | Прибл. значение корня | Прибл. значение функции  |
+-----------------------------+----------+-----------+-----------------------+--------------------------+
| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Ньютона   | 2.265107	             | -0.013699 		|
| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Дихотомии | 2.281250	             | -0.007036 		|
| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Итераций  | 2.302188	             | 0.001474 		|
| 0.25x^3 + x - 1.2502        | [0, 2]   | Ньютона   | 1.038712	             | 0.068685 		|
| 0.25x^3 + x - 1.2502        | [0, 2]   | Дихотомии | 1.031250	             | 0.055228 		|
| 0.25x^3 + x - 1.2502        | [0, 2]   | Итераций  | Не вычислимо	     | -2.500200 		|
+-----------------------------+----------+-----------+-----------------------+--------------------------+
```
Видим, что функция из варианта 17 не вычисляется по формуле итераций. Приведем математическое обоснование:
Условие сходимости итераций: |f'(x)| < 1 <br>
График f(x) = 0.25x<sup>3</sup> + x - 1.2502 <br>
<code>![plot1](/plot1.png)</code> <br>
График первой производной f'(x) = 0.75 * x<sup>2</sup> + 1 <br>
<code>![plot2](/plot2.png)</code> <br>

Имеем: x<sub>0</sub> = 0; f'(x<sub>0</sub>) = 1 - не выполняется условие сходимости. <br>

**Тест 2:**

Ввод: 1e-6

Вывод:

```
f1(x) = 3sin(sqrt(x)) + 0.35x - 3.8
f2(x) = 0.25x^3 + x - 1.2502
Точность: 1e-6
+-----------------------------+----------+-----------+-----------------------+--------------------------+
|         Уравнение           | Отрезок  | Метод     | Прибл. значение корня | Прибл. значение функции  |
+-----------------------------+----------+-----------+-----------------------+--------------------------+
| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Ньютона   | Не вычислимо	     | -0.925587 		|
| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Дихотомии | 2.298536	             | -0.000000 		|
| 3sin(sqrt(x)) + 0.35x - 3.8 | [2, 3]   | Итераций  | 2.298536	             | -0.000000 		|
| 0.25x^3 + x - 1.2502        | [0, 2]   | Ньютона   | 1.000114	             | 0.000000 		|
| 0.25x^3 + x - 1.2502        | [0, 2]   | Дихотомии | 1.000114	             | -0.000001 		|
| 0.25x^3 + x - 1.2502        | [0, 2]   | Итераций  | Не вычислимо	     | -2.500200 		|
+-----------------------------+----------+-----------+-----------------------+--------------------------+
```

Видим, что функция из варианта 16 не вычисляется по формуле Ньютона. Приведем математическое обоснование:
Условие сходимости Ньютона: |f(x) * f''(x)| < (f'(x))<sup>2</sup> <br>
График f(x) = 3sin(x<sup>0.5</sup>) + 0.35x - 3.8 <br>
<code>![plot4](/plot4.png)</code> <br>
График первой производной f'(x) = 3cos(x<sup>0.5</sup>)) * 0.5 * x<sup>-0.5</sup> + 0.35 <br>
<code>![plot5](/plot5.png)</code> <br>
График второй производной f''(x) = -3 * cos(x<sup>0.5</sup>) * 0.25 * x<sup>-1.5</sup> + 3 * sin(x<sup>0.5</sup>) * 0.25 * x<sup>-1</sup> <br>
<code>![plot6](/plot6.png)</code> <br>
Имеем: x<sub>0</sub> = 0; f(x<sub>0</sub>) = 0.206816; f'(x<sub>0</sub>) = 0.215450; f''(x<sub>0</sub>) = -0.226067;<br>
| 0.206816 * -0.226067 | >= 0.215450 - не выполняется условие сходимости. <br>

## 9. Заключение
В работе приведены такие методами решения, как метод дихотомии, итерации и Ньютона. Я составил программу на языке Си с процедурами решения трансцендентных алгебраических уравнений разными численными методами. При этом я получил везде равные значения, а значит, что при решении данного уравнения мы можем использовать все из перечисленных методов. Также я познакомился с передачей функции в качестве аргумента.
