# Отчет по лабораторной работе N 11 по курсу
# "Фундаментальная информатика"

Студент группы: M80-107Б, Павлов Иван Дмитриевич\
Контакты: pavlov.id.2003@mail.ru\
Работа выполнена: 25.09.2021\
Преподаватель: Найденов Иван Евгеньевич\

## 1. Тема

Обработка последовательности литер входного текстового файла. Простейшие приёмы лексического анализа. Диаграммы состояний и переходов.

## 2. Цель работы

Составить программу на языке Си, выполняющую анализ и обработку вводимого текста.

## 3. Задание

№3.

## 4. Оборудование

Процессор: AMD Ryzen 5 4600H with Radeon Graphics\
ОП: 7851 Мб\
НМД: 256 Гб\
Монитор: 1920x1080\

## 5. Программное обеспечение

Операционная система семейства: **linux (ubuntu)**, версия **20.04.3 LTS**\
Интерпретатор команд: **bash**, версия **5.0.17(1)-release**.\
Система программирования: *gcc**, версия **17**\
Редактор текстов: **emacs**, версия **25.2.2**\
Утилиты операционной системы: **--**\
Прикладные системы и программы: **--**\
Местонахождение и имена файлов программ и данных на домашнем компьютере: **--**\

## 6. Идея, метод, алгоритм решения задачи

На вход подается произвольная последовательность ascii-литер. Необходимо посчитать количество слов, заключенных между {} или ```(* *)```. Необходимо использовать матаппарат конечных автоматов. Для его реализации воспользуемся конструкцией enum и switch. Условием на окончание подсчета слов является EOF. Состояниями внутри **switch** являются:
1) S0 - Пропускаем возможные разделители в начале кода. Если c = '{' - переходим в состояние S2, если c = '(' - переходим в состояние S4. Если c является любым ascii-символом, кроме разделителей, переходим в состояние S1.
2) S1 - Начало последовательности. Ищем символы '{' и '('. Если c = '{' - переходим в состояние S2, если c = '(' - переходим в состояние S4.
3) S2 - Первоначальная проверка слов внутри {}. Если с = '}', то переходим в состояние S0, если c - разделитель, то пропускаем его, в противном случае переходим в состояние S3.
4) S3 - Подсчет слов внутри {}. Если c - разделитель, то увеличиваем счетчик, все остальные символы пропускаем, если c = '}', то заканчиваем подсчет и переходим в S0.
5) S4 - ищем символ ```'*'```: если c = ```'*'```, то переходим в состояние S8, иначе переходим в S1;
6) S5 - то же, что S2; если c = ```'*'```, переходим в состояние S8, если с - не разделитель - в состояние S6. Разделители пропускаем.
7) S6 - Подсчет слов внутри ```(* *)```. Если c - разделитель, то увеличиваем счетчик, все остальные символы пропускаем, если c = ```'*'```, переходим в S7.
8) S7 - Проверка на завершение последовательности. Если c = ')', то заканчиваем подсчет и переходим в S0, в противном случае переходим в S9.
9) S8 - Проверка символа ```'*'``` на принадлежность к завершающей последовательности. Если с - разделитель, то увеличиваем счетчик и переходим в S6, если c = ```'*'```, переходим в S9. Если c = ')', то заканчиваем подсчет и переходим в S0.
10) S9 - пропускаем символ ```'*'```; Если c = ')', то заканчиваем подсчет и переходим в S0.       

## 7. Сценарий выполнения работы

#### Конечный автомат

<code>![automat](/automat.png)</code>

#### Тесты.
| Ввод | Вывод | 
| ---- | ----- | 
| Program comments; <br> Var a,b:Integer; <br> Begin<br>(* First *)<br> a:=0;<br>    b:=10;<br>    for a:=1 to 10 do<br>      begin<br>        Write (a*b, ' ');<br>      end;<br>    {  Comment<br>    for a:=1 to 10 do<br>      begin<br>        Write (a*b, ' 'ы);<br>      end;<br>     a b c d}<br>  End. | 17 |

## 8. Распечатка протокола
```
#include <stdio.h>

typedef int bool;
#define TRUE 1
#define FALSE 0

typedef enum {
    S0, S1, S2, S3, S4, S5, S6, S7, S8, S9
} State;

bool is_separator(char c)
{
    if (c == ' ' || c == '\n' || c == '\t') {
        return TRUE;
    }
    return FALSE;
}

int main(void)
{

    char c;
    State state = S0;
    long long cnt = 0;
    long long gcnt = 0;
    bool flag = TRUE;

    while (flag == TRUE) {
        c = getchar();
        switch (state) {
            case S0:
                if (!(is_separator(c)) && (c != '{') && (c != '(')) {
                    state = S1;
                } else if (c == '{') {
                    state = S2;
                } else if (c == '(') {
                    state = S4;
                }
                break;
            case S1:
                if ((c != '{') && (c != '(')) {
                    state = S1;
                } else if (c == '{') {
                    state = S2;
                } else if (c == '(') {
                    state = S4;
                } else {
                    state = S0;
                }
                break;
            case S2:
                if (!is_separator(c) && c != '}') {
                    state = S3;
                } else if (c == '}') {
                    gcnt += cnt;
                    cnt = 0;
                    state = S0;
                }
                break;
            case S3:
                if (!is_separator(c) && c != '}') {
                    state = S3;
                } else if (is_separator(c)) {
                    cnt++;
                    state = S2;
                } else if (c == '}') {
                    cnt++;
                    gcnt += cnt;
                    cnt = 0;
                    state = S0;
                } else {
                    cnt = 0;
                    state = S0;
                }
                break;
            case S4:
                if (c != '*') {
                    state = S1;
                } else if (c == '*') {
                    state = S8;
                }
                break;
            case S5:
                if ((c != '*') && !(is_separator(c))) {
                    state = S6;
                } else if (c == '*') {
                    state = S8;
                }
                break;
            case S6:
                if (!is_separator(c) && c != '*') {
                    state = S6;
                } else if (is_separator(c)) {
                    cnt++;
                    state = S5;
                } else if (c == '*') {
                    state = S7;
                } else {
                    state = S0;
                }
                break;
            case S7:
                if (c != ')') {
                    cnt++;
                    state = S9;
                } else if (c == ')') {
                    cnt++;
                    gcnt += cnt;
                    cnt = 0;
                    state = S0;
                } else {
                    cnt = 0;
                    state = S0;
                }
                break;
            case S8:
                if (c != ')' && c != '*') {
                    state = S6;
                } else if (c == ')') {
                    gcnt += cnt;
                    cnt = 0;
                    state = S0;
                } else if (c == '*') {
                    state = S9;
                } else if (is_separator(c)) {
                    cnt++;
                    state = S6;
                }
                break;
            case S9:
                if (c == '*') {
                    state = S9;
                } else if (c == ')') {
                    gcnt += cnt;
                    cnt = 0;
                    state = S0;
                } else {
                    state = S5;
                }
                break;
        }
        if (c == EOF) {
            flag = FALSE;
        }
    }

    printf("%lld\n", gcnt);

    return 0;
}
```

## 9. Дневник отладки

*Должен содержать дату и время сеансов отладки и основные события (ошибки в сценарии и программе, нестандартные ситуации) и краткие комментарии к ним. В дневнике отладки приводятся сведения об использовании других ЭВМ, существенном участии преподавателя и других лиц в написании и отладке программы.*

| № | Лаб. или дом. | Дата | Время | Событие | Действие по исправлению | Примечание |
| - | ------------- | ---- | ----- | ------- | ----------------------- | ---------- |
| 1 | Лаб | 16.11.2021 | 10:30 | ошибка на тесте 258 | ошибка с подсчетом | Исправил |

## 10. Замечания автора по существу работы


## 11. Выводы

Благодаря данной лабораторной работе я разобрался, как работать с водимыми символами, а так же ознакомился с конструкцией switch case, что поможет мне при написании кода.
