# Реферат по курсу
# "Фундаментальная информатика"

Студент группы: M80-107Б, Павлов Иван Дмитриевич\
Контакты: pavlov.id.2003@mail.ru\
Работа выполнена: 25.12.2021\
Преподаватель: Найденов Иван Евгеньевич\

## 1. Тема

Компилятор, переводящий текст на языке программирования-калькуляторе в код на Машине Тьюринга

## 2. Введение

Пусть существует язык программирования, включающий в себя набор элементарных действий - сложение, вычитание, умножение, деление, выделение памяти для одной переменной. Примерно так работает примитивный, не инженерный калькулятор. Допустим, что принцип работы этого калькулятора основан на Машине Тьюринга и приводится в действие софтом, похожим на знакомый нам web-интерпретатор jstu4-2.3. Однако обычный пользователь не знает ничего о jstu4-2.3. и Машине Тьюринга в целом. Он понимает лишь принцип работы комманд калькулятора. Вывод напрашивается сам собой - необходимо написать компилятор, переводящий код из языка-калькулятора в код на МТ в "четверках", понятный jstu4-2.3.

## 3. Компиляция, LALR-парсинг и Python Lex-Yacc 

Компилятор - программа, транслирующая исходный код на одном языке в объектно-ориентированный код на другом, более низкоуровневом ЯП. Сам процесс компиляции состоит из двух частей - лексического и синтаксического анализа. Лексический анализ - процесс разбиения входной последовательности символов на распознанные лексические единицы (лексемы). Синтаксический анализ - процесс, при котором проверяется грамматика токенов. Результатом является готовое синтаксическое дерево.\
LR-parser (с английского анализатор слева направо) — синтаксический анализатор для исходных кодов программ, написанных на некотором языке программирования, который читает входной поток слева (Left) направо и производит наиболее правую (Right) продукцию контекстно-свободной грамматики. Синтаксис многих языков программирования может быть определён грамматикой, которая является LR(0) или близкой к этому, и по этой причине LR-анализаторы часто используются компиляторами для выполнения синтаксического анализа исходных кодов. Здесь LR(0) — восходящий алгоритм синтаксического разбора контекстно-свободных грамматик, один из видов LR. LR(0) редко применяется на практике из-за узкого класса разбираемых грамматик, но является основой для более мощных алгоритмов SLR(1) и LALR(1), последний из которых имеет богатое практическое применение.\
LALR(1) (где LA - абривеатура от lookahead (англ. предпросмотр)) — восходящий алгоритм синтаксического разбора. Алгоритм разбора или исполнения анализатора по входному потоку, одинаков у LALR(1) и SLR(1), у LR(1) - шире. Отличается он алгоритмами построения таблицы разбора по грамматике в процессе генерации анализатора. Фактически LARL(1) есть обобщение SLR(1). Именно LARL(1) используется в генераторах синтаксических анализаторов, одним из которых является Python Lex-Yacc.\
Python Lex-Yacc - реализация на чистом Python популярных инструментов для создания компиляторов lex и yacc. Модуль поддерживает синтаксический анализа LALR(1), предоставляет обеспечение обширной проверки входных данных, отчеты об ошибках и диагностику. Изначально PLY был создан в Чикагском университете для обучения студентов (кем я и являюсь) в рамках курса "Введение в компилляторы". На данный момент существуют тысячи проектов, включающие PLY. Именно этот инструмент я и буду использовать.

## 4 Лексический анализ

Высокоуровневый язык программирования предельно прост. Он состоит из строчных латинских букв **a-z**, цифр **0-9** и арифметических знаков **+, -, ```*```, /, =**. Поэтому написание лексического анализатора особой трудности не составит.\
Подключим необходимые Python-модули:
``` python
import ply.lex as lex
import ply.yacc as yacc
import re
```
Модуль **re** необходим, так как PLY использует регулярные выражения.

Далее необходимо "разбить" исходный код на токены. Токенам обычно дают имена, описывающие, что именно они из себя представляют.
``` python
#Определяем необходимые токены
tokens = [
	'VAR',      #Переменная
	'NUMBER',   #Число
	'PLUS',     #Знак сложения
	'MINUS',    #Знак вычитания
	'MULTIPLY', #Знак умножения
	'DIVIDE',   #Знак деления
	'EQUALS'    #Знак равенства
]
```
Модуль **lex** подразумевает собой обязательное наличие в коде массива с названием **tokens**. Кроме того мы обязаны для каждого элемента массива иметь регулярное выражение (или функцию) с названием **t_ЭЛЕМЕНТ_МАССИВА**. Сделано это потому, что модуль не работает с массивом напрямую, а создает файл **lextab.py**, содержащий таблицы переходов и регулярные выражения. Это позволяет программе не строить каждый раз новую таблицу переходов, а использовать сгенерированную.
``` python
#Задаем регулярные выражения для каждого из элементов массива:
t_VAR = r'[a-z]\w*'
t_NUMBER = r'\d+'
t_PLUS = r'\+'
t_MINUS = r'\-'
t_MULTIPLY = r'\*'
t_DIVIDE = r'\/'
t_EQUALS = r'\='
```
Кроме того на вход может поступить символ "\n" или вообще неподходящий под токенизацию символ. Такие случаи опишем в виде функций:
``` python
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

t_ignore  = ' \t'

def t_error(t):
    t.lexer.skip(1)
```
**t.lexer.lineno** - атрибут номера строки из **ply.lex** в данном случае мы прибавляем 1 к номеру строки (прибавляем длину "\n", так как мы не можем прибавить строку к вещественному числу). Функция **t_error** обязательно должна присутствовать в коде. Мы используем атрибут **skip**, чтобы пропустить этот элемент.\
Далее необходимо запустить сам лексер:
``` python
lexer = lex.lex()
```
Лексический анализатор готов. Прежде чем перейти к синтаксическому анализу, необходимо разобраться в аспектах нашего низкоуровневого языка - Машины Тьюринга.

## 5. Описание Машины Тьюринга и jstu4-2.3.

Машиной Тьюринга называется упорядоченный набор объектов из множества, включающего рабочий алфавит, имена состояний и собственно программу (запись символа, сдвиг головки).\
jstu4-2.3. (web-интерпретатор, написанный в 2011 году Алексеем Дубининым) использует частный случай этого определения - модель МТ в "четверках", состоящую из набора **{q,a,v,q'}**, где:
<ul>
  <li> <b>q</b> - символ текущего состояния головки.</li>
  <li> <b>a</b> - буква, записанная в текущей рабочей ячейке.</li>
  <li> <b>v</b> - символ выполняемого действия </li>
  <li> <b>q'</b> - символ состояния, в которое команда переводит головку </li>
 </ul>
 При этом и сам интерпретатор обладает рядом особенностей, которые следует учитывать при написании кода. Вот некоторые из них:
 1) Машина Тьюринга обладает одной лентой.
 2) Лента не является бесконечной и ограничена с левого конца.
 3) Умолчальный пробел отсутствует, поэтому не получится запустить программу с пустой лентой.
 4) Машина не выдает ошибку, если не описаны все команды для одного состояния и всего рабочего алфавита.
 5) Рабочий алфавит МТ по умолчанию не задается и при желании можно записать на ленту любой ascii-символ.
 6) В коде программы должно быть начальное состояние **0**.
 Синтаксис МТ, принимаемой интерпретатором:
 <ul>
  <li> <b><</b> - сдвиг головки влево </li>
  <li> <b>></b> - сдвиг головки вправо </li>
  <li> <b>=</b> - положение головки не меняется </li>
  <li> <b>#</b> - закончить выполнение программы </li>
  <li> символ "пробел" обозначается пробелом, а не знаком <b>λ</b> </li>
</ul>
В остальном язык совпадает с представлением МТ в "четверках".

## 6. Синтаксический анализ

Приступим к описанию грамматики языка. В PLY это реализуется написанием функций **P_ИМЯ_ФУНКЦИИ**, сам же синтаксис описывается в doc-строках Python. Изначально мы уже знаем, из чего именно может состоять наш высокоуровневый ЯП, поэтому напишем функцию **p_expression** (с англ. Выражение):

``` python
def p_expession(p):
	'''
	expression : expression MULTIPLY expression
	           | expression DIVIDE expression
	           | expression PLUS expression
	           | expression MINUS expression
	           | VAR PLUS expression
	           | expression PLUS VAR
	           | VAR PLUS VAR
	           | expression MINUS VAR
	           | VAR MINUS expression
	           | VAR MINUS VAR
	           | expression MULTIPLY VAR
	           | VAR MULTIPLY expression
	           | VAR MULTIPLY VAR
	           | expression DIVIDE VAR
	           | VAR DIVIDE expression
	           | VAR DIVIDE VAR
	
	'''
	p[0] = (p[2], p[1], p[3])
	
def p_var_assign(p):
	'''
	var_assign : VAR EQUALS expression
	'''
	p[0] = (p[2], p[1], p[3])
```
Описание функции **p_expression** интуитивно понятно. Отдельно вынесли также функцию **p_var_assign** (присвоение переменной значения).\
Функции присваивает нулевому элементу данного масссива кортеж из элементов массива токенов. Таким образом, нулевой элемент содержит все необходимое для дальнейшего построения кода на МТ. Очень удобно.\
Не менее важными являются и следующие функции:
``` python
def p_expression_number(p):
	'''
	expression : NUMBER
	'''
	p[0] = p[1]

def p_error(p):
    print("Syntax error in input!")
```
Таким образом наш анализатор понимает, что такое **expression** (присваиваем ему токен **NUMBER**) , и исключает теперь уже синтаксические ошибки.\
Далее, самая главная функция - то, ради чего мы описывали все прошлые функции - генератор МТ:
``` python
def p_mt(p):
	'''
	mt : expression
	   | var_assign
	'''
	print(run(p[1]))
```
Как видим, функция выведет в консоль результат выполнения некой функции **run** (о ней в следующем пункте), в качестве аргумента у которой выступает **mt**, который представляет собой результат работы функции **p_expression** или **p_var_assign**. Логическая цепочка завершена, осталось только запустить парсер:
``` python
parser = yacc.yacc()
```

## 7. Пишем Машины Тьюринга

Так как наш калькулятор умеет складывать, умножать, вычитать, делить и запоминать одну переменную, то нам понадобится 5 машин Тьюринга с динамическим (если так можно выразиться) изменением состояний (имеется ввиду что номер состояния МТ может изменяться в зависимости от введенных в консоль значений).\
Функция **run** определяет, какую именно из этих машин мы собираемся выводить.
``` python
def run(p):
	if type(p) == tuple:
		if p[0] == '+':
			return mt_plus(p[1], p[2])
		elif p[0] == '-':
			return mt_minus(p[1], p[2])
		elif p[0] == '*':
			return mt_multiply(p[1], p[2])
		elif p[0] == '/':
			return mt_divide(p[1], p[2])
		elif p[0] == '=':
			return mt_var_assign(p[1], p[2])	
	else:
		return p
```
Принцип работы прост: если тип элемента - кортеж, то выводим одну из 5 машин (5 if-ов говорят сами за себя). В противном случае программа выведет ошибку.\
В свою очередь эти 5 сложных машин состоят из более простых МТ, каждую из которых мы далее опишем.\
Введем 2 переменные: **mt_state** и **var_memo**. Первой присвоим текущее состояние МТ, второй - значение переменной высокоуровневого языка.\
Далее я опишу принцип генерации и работы моих МТ, начиная от самых простых, заканчивая пятью основными МТ.

### Cдвиг головки влево (вправо), если на ленте пробел
``` python
def mt_left_lambda(void):
	global mt_state
	mt_code = '%s, ,<,%s\n' %(hex(mt_state)[2:], hex(mt_state + 1)[2:])
	mt_state += 1
	return mt_code
	
def local_left_lambda(local_state):
	mt_code = '%s, ,<,%s\n' %(hex(local_state)[2:], hex(local_state + 1)[2:])
	return mt_code
	
def mt_right_lambda(void):
	global mt_state
	mt_code = '%s, ,>,%s\n' %(hex(mt_state)[2:], hex(mt_state + 1)[2:])
	mt_state += 1
	return mt_code
	
def local_right_lambda(local_state):
	mt_code = '%s, ,>,%s\n' %(hex(local_state)[2:], hex(local_state + 1)[2:])
	return mt_code
```
Весь код на МТ представляет собой Python-строку, состояния МТ реализованы с помощью форматного вывода Python. Сами состояния представляют собой шестнадцатеричные числа (преобразованные в строковый шестнадцатеричный вид десятичные числа с помощью стандартной функции **hex**). 2 первых символа **0x** будут конфликтовать с рабочим алфавитом МТ, поэтому их убираем.\
Кстати, о рабочем алфавите: он включает в себя строчные латинские буквы, десяттичные цифры, а так же символы ```_```, | и -.\
В коде представлены две функции сдвига головки: одна из них использует **mt_state** как глобальную переменную и увеличивает ее на 1, вторая - принимает на вход состояние и никак его не изменяет. Вторая была написана для удобства при создании некоторых более сложных МТ.\

### Сдвиг головки на число влево(вправо)
``` python
def mt_left_shift_word(void):
	global mt_state
	mt_code = ''.join(['%s,%s,<,%s\n' %(hex(mt_state)[2:] , hex(i - 1)[2:] , hex(mt_state)[2:]) for i in range(1, 11)]) + ('%s, ,=,%s\n' %(hex(mt_state)[2:] , hex(mt_state + 1)[2:]))
	mt_state += 1
	return mt_code

def local_left_shift_word(local_state):
	mt_code = ''.join(['%s,%s,<,%s\n' %(hex(local_state)[2:] , hex(i - 1)[2:] , hex(local_state)[2:]) for i in range(1, 11)]) + ('%s, ,=,%s\n' %(hex(local_state)[2:] , hex(local_state + 1)[2:]))
	return mt_code

def mt_right_shift_word(void):
	global mt_state
	mt_code = ''.join(['%s,%s,>,%s\n' %(hex(mt_state)[2:] , hex(i - 1)[2:] , hex(mt_state)[2:]) for i in range(1, 11)]) + ('%s, ,=,%s\n' %(hex(mt_state)[2:] , hex(mt_state + 1)[2:]))
	mt_state += 1
	return mt_code 
def local_right_shift_word(local_state):
	mt_code = ''.join(['%s,%s,>,%s\n' %(hex(local_state)[2:]def mt_plus(a, b):
	global mt_state
	global var_memo
	mt_code = ''
	if a.isdigit() and b.isdigit():
		mt_code += mt_read(a,b)
		mt_code += mt_left_lambda(mt_state)
		mt_code += mt_left_shift_word(mt_state)
		mt_code += mt_copy(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_right_shift_word(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_right_shift_word(mt_state)
		mt_code += mt_left_lambda(mt_state)
		mt_code += mt_insignificant_zeros(mt_state)
		mt_code += mt_inc_dec(mt_state)
		mt_code += mt_recovery(b)
		mt_code += mt_end(mt_state)
	else:
		if a.isdigit():
			mt_code += mt_read(a,b)
		elif b.isdigit():
			mt_code += mt_read(b,a)
		else:
			mt_code += mt_read(var_memo,a)
		mt_code += mt_left_lambda(mt_state)
		mt_code += mt_var_copy(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_right_shift_word(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_right_shift_word(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_inc_dec(mt_state)
		if a.isdigit():
			mt_code += mt_recovery(a)
		elif b.isdigit():
			mt_code += mt_recovery(b)
		else:
			mt_code += mt_recovery(var_memo)
		mt_code += mt_end(mt_state)
	mt_state = 0
	return mt_code , hex(i - 1)[2:] , hex(local_state)[2:]) for i in range(1, 11)]) + ('%s, ,=,%s\n' %(hex(local_state)[2:] , hex(local_state + 1)[2:]))
	return mt_code
```
Помимо форматного вывода в коде присутствуют знаменитые питоно-циклы в одну строку. Цикл необходим здесь для перечисления всех возможных цифр из алфавита 0-9. Здесь также 2 способа задания подобной МТ по причинам, описанным выше.

### Сдвиг головки на слово влево(вправо)
``` python
def mt_right_var(mt_state):
	mt_code = ''
	mt_code += ''.join(['%s,%s,>,%s\n' %(hex(mt_state)[2:], chr(i + 97), hex(mt_state)[2:]) for i in range(26)])
	return mt_code
	
def mt_left_var(mt_state):
	mt_code = ''
	mt_code += ''.join(['%s,%s,<,%s\n' %(hex(mt_state)[2:], chr(i + 97), hex(mt_state)[2:]) for i in range(26)])
	return mt_code
```
Принцип тот же, что и с предыдущей МТ, но вместо цифр идут латинские буквы. Их я сгенерировал с помощью **chr(i + 97)**, где 97 = **ord(a)**.

### Конец программы
``` python
def mt_end(void):
	global mt_state
	mt_code = ''
	mt_code += ''.join('%s, ,#,0\n' %(hex(mt_state)[2:]))
	return mt_code
```
Эта МТ завершает выполнение всей программы.\

Далее идут уже сложные МТ, в том числе включающие в себя предыдущие МТ. Код многих из них в отчете приводить не буду ввиду его громоздкости (все таки МТ пишем)\

### Запись числа на ленту
``` python
def mt_read(a, b):
	global mt_state
	mt_code = ''
	for i in range(len(a)):
		mt_code += '%s, ,%s,%s\n' %(hex(mt_state)[2:] , a[i] , hex(mt_state + 1)[2:])
		mt_state += 1
		mt_code += '%s,%s,>,%s\n' %(hex(mt_state)[2:] , a[i] , hex(mt_state)[2:])
	mt_code += '%s, ,>,%s\n' %(hex(mt_state)[2:] , hex(mt_state + 1)[2:])
	mt_state += 1
	for i in range(len(b)):
		mt_code += '%s, ,%s,%s\n' %(hex(mt_state)[2:] , b[i] , hex(mt_state + 1)[2:])
		mt_state += 1
		mt_code += '%s,%s,>,%s\n' %(hex(mt_state)[2:] , b[i] , hex(mt_state)[2:])
	return mt_code
```
Таким образом мы записываем на ленту те самые числа, которые ввели.

### Копия числа
Копирование числа - очень большая по объему МТ, которая работает по следующему принципу:
1) вместо цифры ставим пробел, переходим в состояние, зависящее от конкретной цифры
2) для каждого состояния идем в конец, записываем необходимую цифру
3) возвращаемся в начало, вместо пробела ставим необходимую цифру, и так пока число не закончится

``` python
def mt_copy(void):
	global mt_state
	local_state = 0
	mt_code = ''
	mt_code += mt_left_lambda(mt_state)
	mt_code += mt_left_shift_word(mt_state)
	mt_code += mt_right_lambda(mt_state)
	mt_code = mt_code + ''.join(['%s,%s, ,%s\n%s, ,>,%s\n' %(hex(mt_state)[2:] , hex(i - 1)[2:] , hex(10000 + i * 100)[2:] , hex(10000 + i * 100)[2:] , hex(10000 + i * 100 + 1)[2:]) for i in range(1, 11)])
	mt_code += local_copy(local_state)
	return mt_code
```
В 8й строке этой МТ мы переходим сразу в 10 состояний, соответствующих каждой цифре. МТ **local_copy** - как раз описанные выше действия для каждой цифры:
``` python
def local_copy(local_state):
	mt_code = ''
	local_state = 10101
	
	mt_code += local_right_shift_word(local_state)
	local_state += 1
	mt_code += local_right_lambda(local_state)
	local_state += 1
	mt_code += local_right_shift_word(local_state)
	local_state += 1
	mt_code += local_right_lambda(local_state)
	local_state += 1
	mt_code += local_right_shift_word(local_state)
	local_state += 1
	mt_code += ''.join('%s, ,0,%s\n' %(hex(local_state)[2:] , hex(local_state + 1)[2:]))
	local_state += 1
	mt_code += local_left_shift_word(local_state)
	local_state += 1
	mt_code += local_left_lambda(local_state)
	local_state += 1
	mt_code += local_left_shift_word(local_state)
	local_state += 1
	mt_code += local_left_lambda(local_state)
	local_state += 1
	mt_code += local_left_shift_word(local_state)
	local_state += 1
	mt_code += ''.join('%s, ,0,%s\n' %(hex(local_state)[2:] , hex(local_state + 1)[2:]))
	local_state += 1
	mt_code += ''.join('%s,0,>,%s\n' %(hex(local_state)[2:] , hex(mt_state)[2:]))
```
И таких состояний 10, для каждой цифры.\

Аналогичная ситуация и с копированием переменной:
``` python
def mt_var_copy(void):
	global mt_state
	mt_code = ''
	mt_code += ''.join(['%s,%s, ,%s\n' %(hex(mt_state)[2:] , chr(i + 96) , hex(12000 + 100)[2:]) for i in range(1, 27)])
	mt_code += ''.join('%s, ,<,%s\n' %(hex(12000 + 100)[2:] , hex(12000 + 100 + 1)[2:]))
	local_state = 12100
	local_state += 1
	mt_code += local_left_lambda(local_state)
	local_state += 1
	mt_code += local_left_shift_word(local_state)
	local_state += 1
	mt_code += '%s, ,<,%s\n' %(hex(local_state)[2:], hex(mt_state + 1)[2:])
	mt_code += mt_copy(mt_state)
	return mt_code
```

### Cложение и вычитание
``` python
def mt_plus(a, b):
	global mt_state						#Добавляем глобальные переменные
	global var_memo
	mt_code = ''
	if a.isdigit() and b.isdigit():				#Проверяем тип вводимых данных
		mt_code += mt_read(a,b)				#Записываем данные на ленту
		mt_code += mt_left_lambda(mt_state)
		mt_code += mt_left_shift_word(mt_state)
		mt_code += mt_copy(mt_state)			#Копируем первое слогаемое
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_right_shift_word(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_right_shift_word(mt_state)
		mt_code += mt_left_lambda(mt_state)
		mt_code += mt_insignificant_zeros(mt_state)
		mt_code += mt_inc_dec(mt_state)			#Собственно, сложение
		mt_code += mt_recovery(b)			#Восстанавливаем исходные данные
		mt_code += mt_end(mt_state)
	else:
		if a.isdigit():					
			mt_code += mt_read(a,b)
		elif b.isdigit():
			mt_code += mt_read(b,a)
		else:
			mt_code += mt_read(var_memo,a)
		mt_code += mt_left_lambda(mt_state)
		mt_code += mt_var_copy(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_right_shift_word(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_right_shift_word(mt_state)
		mt_code += mt_right_lambda(mt_state)
		mt_code += mt_inc_dec(mt_state)
		if a.isdigit():
			mt_code += mt_recovery(a)
		elif b.isdigit():
			mt_code += mt_recovery(b)
		else:
			mt_code += mt_recovery(var_memo)
		mt_code += mt_end(mt_state)
	mt_state = 0						#Обнуляем состояние МТ
	return mt_code
```
Принцип работы функции сложение:
1) Проверяем, являются ли входные данные числами. Если да, то копируем первое число ко второму и выполняем сложение
2) Если нет, то смотрим, с какой стороны от знака + находилась переменная, в зависимости от этого выведем на ленту в порядке: число, переменная. Это нужно для того, чтобы не писать еще больше МТ.
3) Само сложение работает так: вычитаем 1 из одного из слагаемых, прибавляем 1 к копии. И так, покаможно вычитать.
4) Функция **mt_recovery** восстанавливает исходные данные, чтобы результат на ленте имел стандартный вид.

Вычитание отличается от сложения тем, что мы вычитаем из копии 1, а не прибавляем.

### Умножение
А вот алгоритм умножения уже куда более интересен:
1) Переводим оба числа в кардинальную СС
2) Копируем второй множитель столько раз, сколько знаков | в первом множителе
3) Переводим обратно в десятичную СС

### Деление
1) Переводим оба числа в кардинальную СС
2) Копируем делитель к делимому
3) если вычлось, то добавляем 1 к результату деления. Потом опять переходим на шаг (в состояние) 1. Так делаем до тех пор, пока удаётся вычитать. Если вычесть не удалось, то очищаем на ленте всё, кроме результата деления.
4) Переводим в десятичную СС

### Присваивание переменной
1) Записываем слева от ленты значение переменной.
2) Отступаем левее, пишем переменную, затем знак _ (чтобы не описывать 26 состояний)

## 8. Доработка и особенности

### Консоль
В окончание необходимо реализовать консольные ввод и вывод:
``` python
while True:
   try:
       s = input('')
   except EOFError:
       break
   if not s: continue
   result = parser.parse(s)
```
Здесь я запустил цикл, который будет работать, пока на вход не поступит символ EOF, либо не произойдет ошибка на уровне Python.

### Создаем exe-файл
Понятно, что многие не знакомы с Python, поэтому неплохо будет создать exe-файл, запускаемый из терминала, который и будет результатом нашей работы. Для этого воспользуемся модулем **pyinstaller**, пропишем в терминале:
``` bash
ggame@ggame:~/referat/mt2$ pyinstaller mt2.py 
```
Таким образом мы скомпилировали Python-файл, тем самым полностью отвязав его от Python.

### Особенности совместной работы **mt2** и **jstu4-2.3**
Пусть теперь мой софт называется mt2 (от "2 Turing" или "To Turing")
<ul>
	<li> Так как на jstu4-2.3 нельзя начать работу с пустой ленты, то запишем на середине ленты 0 - необходимое условие для начала работы mt2 </li>
	<li> Операции сложения, вычитания, умножения и деления оканчиваются машиной mt_end и обнуляет состояние МТ, присваивание переменной - нет. </li>
	<li> Что с отрицательными числами? выражения по типу -5 * 4 будут скомпилированы, но на ленте они будут представлены по модулю. Попытка написать 5 * -3 приведет к синтаксической ошибке, предусмотренной парсером, из за несоответствия синтаксису языка (скобок в нем нет). На ленте отрицательное число может получиться только в одном случае - при вычитании, если вычитание будет по модулю превосходить уменьшаемое. Этот случай был прописан в машине mt_dec-dec (декремент). <li>
</ul>

## 9. Заключение

В данной работе я:
<ul>
	<li>Ознакомился с принципом работы компиляторов; </li>
	<li>Изучил модуль Python lex-yacc;</li>
	<li>Сгенерировал огромное количество кода на МТ, тем самым отточил навыки работы со строками в Python;</li>
	<li>Скомпилировал Python-файл;</li>
	<li>Окончательно убедился в том, что Машина Тьюринга осталась далеко в прошлом.</li>
</ul>
Надеюсь, что опыт, приобретенный в процессе выполнения этой работы, пригодится мне в следующих проектах.

## 10. Использованная литература

http://www.dabeaz.com/ply/ply.html#ply_nn5 - документация PLY \
https://ru.wikipedia.org/wiki/LALR(1) - описание LALR(1) \
С.С.Гайсарян, В.Е.Зайцев. Курс Информатики. - интересная и полезная учебная литература

