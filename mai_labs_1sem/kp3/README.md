# Курсовая работа по курсу «Вычислительные системы» (первый семестр)

Студент группы: M80-107Б, Павлов Иван Дмитриевич\
Контакты: pavlov.id.2003@mail.ru\
Работа выполнена: 09.12.2021\
Преподаватель: Найденов Иван Евгеньевич\

## 1. Тема

Вещественные числа в языке C.

## 2. Цель работы

Написать программу на языке Си, которая выводит таблицу значений элементарной функции в заданном диапазоне двумя способами: по формуле Тейлора и с помощью функций как из библиотеки math.h, так и написанных в тексте кода. В качестве аргументов таблицы взят единичный отрезок, который представляет собой верхнюю точку i-го разбиения данного отрезка [a, b] на n равных частей, помноженный на номер итерации. Вычисления по формуле Тейлора будем проводить до заданной точности ε * pow(10, k), где ε - машинный эпсилон аппаратно реализованного вещественного типа для данной ЭВМ, а k – экспериментально подбираемый коэффициент, обеспечивающий приемлемую сходимость. Программа должна сама определять машинный ε и обеспечивать корректные размеры генерируемой таблицы.

## 3. Задание

| №  | Ряд Тейлора | Функция | a | b |
| -- | ----------- | ------- | - | - |
| 24 | <code>![taylor](/taylor.png)</code>| <code>![f](/f.png)</code> | 0.0 | 1.0 | 

## 4. Теоретическая часть

**Ряд Тейлора** — разложение функции в бесконечную сумму степенных функций. Ряды Тейлора применяются при аппроксимации функции многочленами.\
**Машинный эпсилон** (Machine epsilon) — числовое значение, меньше которого невозможно задавать относительную точность для любого алгоритма, возвращающего вещественные числа.\
**Машинный ноль** — числовое значение с таким отрицательным порядком, которое воспринимается машиной как ноль.

## 5. Текст кода

```
#include <stdio.h>
#include <math.h>

int fact(int n)
{
    if (n == 0 || n==1)
        return 1;
    else
    {
        return n * fact(n - 1);
    }
}

long double machine_epsilon(void)
{
	long double e = 1.0f;
	while (1.0f + e / 2.0f > 1.0f)
		e /= 2.0f;
	return e;
}

int main()
{
	printf("Введите количество равных разбиений отрезка [a, b]: n = ");
	int n;
	scanf("%d", &n);
	if (n < 1) {
		printf("Введенное значение должно быть больше нуля!\n");
		return 0;
	}
	double e0 = machine_epsilon();
	double d = 1 / (double)n;
	printf("Машинное эпсилон для типа long double: e = %.8e\n", e0);
	printf("+-----------------------------------------------------------------------------------------------------+\n");
	printf("|            Таблица значений ряда Тейлора и стандартной функции для f(x) = exp(pow(x, 2))            |\n");
	printf("+-------+-----------------------------------------+---------------------------------+-----------------+\n");
	printf("|   x   | частичная сумма ряда для exp(pow(x, 2)) |      значение функции f(x)      | число итераций  |\n");
	printf("+-------+-----------------------------------------+---------------------------------+-----------------+\n");
	double x = 0.0;
	for (int i = 0; i <= n; i++) {
		x = d * i;
		double math_func = exp(pow(x, 2));
		double res = 0;
		int n1 = 0;
		double numerator = 1;
		double denominator = 1;
		for(;;n1++)
		{
			double cur = numerator / denominator;
			if(fabs(cur) < e0)
				break;
			res += cur;
			numerator *= x * x;
			denominator *= fact(n1 + 1);
		}
		printf("| %.3f\t|          %.19f          |      %.19f      |        %d        |\n", x, res, math_func, n1);
	}
	printf("+-------+-----------------------------------------+---------------------------------+-----------------+\n");
	return 0;
}
```

## 6. Описание кода

1) Подключаем заголовочный файл **math.h** для вызова функций **pow()**, **exp()** и **fabs()**, напишем функцию **fact()**, возвращающую факториал. Так как функция **fact()** определена только для целых чисел и возвращает целое число, то ее вызов никак не повлияет на погрешность результата.
2) Задаем машинный эпсилон для типа long double при помощи функции **machine_epsilon()**, которая делит переменную **e** на 2 пока (1 + **e**/2) > 1. Если (1 + **e**/2) = 1, то **e** будет равно машинному нулю; функция возвращает результат предыдущей итерации. Присваиваем его переменной **e0**.
3) Задаем ввод количества равных разбиений отрезка [a,b], **n**, если **n** > 1, то объявляем число **d**, равное **b**/**n** - единичный отрезок.
4) Объявляем **x** типа double - аргумент f(x).
5) В цикле for проходим по всем точкам разбиений {0, n}, присваиваем аргументу значение **d** * i (произведение единичного отрезка на номер итерации), вычисляем значение данной функции **math_func** с помощью функций из **math.h**.
6) Суммируем данный ряд Тейлора, объявляем переменные **res** - результат, **n1** - количество итераций, определяющее точность значения f(x), **numenator** и **denomenator** - числитель и знаменатель члена ряда.
7) Первый член ряда Тейлора уже задан объявим **cur** - значение дроби, начиная со второго члена циклически умножаем числитель и знаменатель согласно условию, прибавляем к переменной **res** значение дроби. Условие на выход из цикла: если модуль значения члена ряда меньше **e0**.
8) В виде таблицы выводим переменные **x**, **res**, **math_func**, **n1**.

## 7. Запуск кода

### Формат входных данных:

На ввод подаётся одно число - количество равных разбиений отрезка [a,b].

### Формат результата:

Прежде всего выводится машинный эпсилон, затем n + 1 строка таблицы (не считая шапки). В каждой строке выводится: значение x, для которого вычисляется функция; значение, вычисленное с помощью формулы Тейлора; значение, вычисленное с помощью встроенных функций языка, количество итераций.

## 8. Протокол исполнения и тесты

Тест #1:

Ввод: 10

Вывод:

```
Введите количество равных разбиений отрезка [a, b]: n = 10
Машинное эпсилон для типа long double: e = 1.08420217e-19
+-----------------------------------------------------------------------------------------------------+
|            Таблица значений ряда Тейлора и стандартной функции для f(x) = exp(pow(x, 2))            |
+-------+-----------------------------------------+---------------------------------+-----------------+
|   x   | частичная сумма ряда для exp(pow(x, 2)) |      значение функции f(x)      | число итераций  |
+-------+-----------------------------------------+---------------------------------+-----------------+
| 0.000	|          1.0000000000000000000          |      1.0000000000000000000      |        1        |
| 0.100	|          1.0100500833680585711          |      1.0100501670841679491      |        6        |
| 0.200	|          1.0408053422251855036          |      1.0408107741923882106      |        7        |
| 0.300	|          1.0941109779833808613          |      1.0941742837052104154      |        8        |
| 0.400	|          1.1731436119236373639          |      1.1735108709918102843      |        8        |
| 0.500	|          1.2825656749682174951          |      1.2840254166877413944      |        8        |
| 0.600	|          1.4287464950474864089          |      1.4333294145603403535      |        8        |
| 0.700	|          1.6200550679383909358          |      1.6323162199553791218      |        9        |
| 0.800	|          1.8672309852094397531          |      1.8964808793049516833      |        9        |
| 0.900	|          2.1838415282397685147          |      2.2479079866764717366      |        9        |
| 1.000	|          2.5868345309364717544          |      2.7182818284590450908      |        9        |
+-------+-----------------------------------------+---------------------------------+-----------------+
```

## 9. Заключение

В работе приведены определения машинного эпсилон, машинного нуля, формулы Тейлора. Была составлена программа на языке Си, выводящая значения заданной функции на заданном отрезке с заданной точностью двумя способами: по формуле Тейлора и стандартными функциями языка. Можно сделать вывод, что при помощи стандартных функций были получены более точные значения, это связано с ограниченной точностью системы. Именно поэтому способ Тейлора редко применяется на практике. 
